#!KAMAILIO

# A few runtime constants.

#!define PUSH_API_BASE_PATH_FCM "http://172.30.110.2:8084/push-fcm"
#!define PUSH_API_BASE_PATH_APNS "http://172.30.110.2:8084/push-apns"

debug=2
children=8
mhomed=1
enable_tls=1
tcp_accept_no_cl=yes
tcp_max_connections=16384
tls_max_connections=16348
alias=webrtc00.hovernetworks.net
socket_workers=2
listen=udp:38.101.40.92:8060
listen=tls:38.101.40.92:443
socket_workers=4
listen=tcp:38.101.40.92:8060
log_facility=LOG_LOCAL0

loadmodule "pv"
loadmodule "xlog"
loadmodule "ipops"
loadmodule "sdpops"

loadmodule "cfgutils"
modparam("cfgutils", "lock_set_size", 10)

loadmodule "tm"
modparam("tm", "blst_503", 0)
modparam("tm", "cancel_b_method", 1)
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 10000)
modparam("tm", "fr_inv_timer", 60000)
modparam("tm", "noisy_ctimer", 1)
modparam("tm", "reparse_invite", 1)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "unmatched_cancel", 1)

loadmodule "rr"
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)
modparam("rr", "enable_full_lr", 1)

loadmodule "rtpengine"
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:5050")
modparam("rtpengine", "rtpengine_retr", 1)

loadmodule "db_mysql"
modparam("db_mysql", "ping_interval", 30)
modparam("db_mysql", "timeout_interval", 1) # really, 3 sec.
modparam("db_mysql", "auto_reconnect", 1)

loadmodule "tls"
modparam("tls", "con_ct_wq_max", 1048576)
modparam("tls", "connection_timeout", 300)
modparam("tls", "ct_wq_max", 26214400)
modparam("tls", "renegotiation", 1)
modparam("tls", "require_certificate", 0)
modparam("tls", "send_close_notify", 1)
modparam("tls", "tls_disable_compression", 1)
modparam("tls", "tls_method", "TLSv1.1+")
modparam("tls", "verify_certificate", 0)
modparam("tls", "private_key", TLS_SERVER_KEY)
modparam("tls", "certificate", TLS_SERVER_CERT)

loadmodule "sanity"
modparam("sanity", "default_checks", 359)

loadmodule "kex"
loadmodule "maxfwd"
loadmodule "nathelper"
loadmodule "jansson"
loadmodule "siputils"
loadmodule "sl"
loadmodule "textops"
loadmodule "textopsx"
loadmodule "tmx"
loadmodule "xhttp"

loadmodule "websocket"
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 3)
modparam("websocket", "keepalive_interval", 5)
modparam("websocket", "cors_mode", 1)

loadmodule "ctl"
modparam("ctl", "binrpc", "unixs:/tmp/kamailio_ctl")
modparam("ctl", "binrpc_buffer_size", 1048576)
modparam("ctl", "mode", 0600)
modparam("ctl", "binrpc_max_body_size", 1024)
modparam("ctl", "binrpc_struct_max_body_size", 1024)

loadmodule "htable"
modparam("htable", "htable", "ib_trans=>size=12;autoexpire=120")

loadmodule "http_client"
modparam("http_client", "httpredirect", 1)
modparam("http_client", "connection_timeout", 2)
modparam("http_client", "verify_peer", 0)
modparam("http_client", "verify_host", 0)
modparam("http_client", "tlsversion", 0)
modparam("http_client", "query_result", 1)
modparam("http_client", "httpcon", "push_api=>http://172.30.110.2:8084")

loadmodule "usrloc"
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "desc_time_order", 1)
modparam("usrloc", "hash_size", 16)
modparam("usrloc", "matching_mode", 0)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 2)
modparam("usrloc", "use_domain", 1)

loadmodule "registrar"
modparam("registrar", "default_expires", 300)
modparam("registrar", "min_expires", 20)
modparam("registrar", "max_expires", 300)
modparam("registrar", "append_branches", 1)
modparam("registrar", "max_contacts", 10)
modparam("registrar", "gruu_enabled", 1)
modparam("registrar", "contact_max_size", 1024)

loadmodule "tsilo"
modparam("tsilo", "hash_size", 2048)
modparam("tsilo", "use_domain", 1)

loadmodule "mqueue"
modparam("mqueue", "mqueue", "name=push_q")
modparam("mqueue", "mqueue", "name=inbound_q")

loadmodule "rtimer"
modparam("rtimer", "timer", "name=push_timer;interval=10000u;mode=1")
modparam("rtimer", "exec", "timer=push_timer;route=PUSH_TIMER")
modparam("rtimer", "timer", "name=inbound_timer;interval=10000u;mode=1")
modparam("rtimer", "exec", "timer=inbound_timer;route=INBOUND_TIMER")

request_route {
    $avp(ws_origin) = 0;

    # Some basic sanity checks.

    if(!mf_process_maxfwd_header("10") && !is_method("REGISTER|OPTIONS")) {
        send_reply("483", "Too Many Hops");
        exit;
    }

    if(!sanity_check())
        exit;

    if(proto == WS || proto == WSS) {
        force_rport();
        $avp(ws_origin) = 1;
    }

    # In-dialog request handling.
    if(has_totag()) {
        if(loose_route()) {
            xlog("L_INFO", "[R-MAIN:$ci] Processing in-dialog request $rm $ru from $si:$sp\n");

            handle_ruri_alias();

            if(is_method("INVITE|UPDATE")) {
                if(has_body("application/sdp")) {
                    if(proto == WS || proto == WSS) {
                        rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
                    } else {
                        rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU");
                    }
                }

                # Keep up with any target refreshes.
                if(!is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
                    add_contact_alias();
                    t_on_reply("REPLY_FROM_PBX");
                } else {
                    t_on_reply("REPLY_FROM_ENDPOINT");
                }
            } 

            if(!t_relay()) 
                sl_reply_error();
        } else {
            if(is_method("ACK")) {
                if(t_check_trans())
                    t_relay();

                exit;
            }

            send_reply("403", "Forbidden");
        }

        exit;
    }

    if(is_method("CANCEL")) {
        if(!t_relay_cancel())
            send_reply("500", "Internal Server Error");

        exit;
    }

    # Retransmission dampening, then handle initial requests.
    t_check_trans();

    # If there is a foreign domain, make sure it matches the upstream 
    # trusted PBX, otherwise reject.

    if(!uri == myself && !is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
        if(!is_in_subnet("$rd", PBX_SERVER_ADDRESSES)) {
            send_reply("403", "Relay not permitted");
            exit;
        }

        xlog("L_INFO", "[R-MAIN-REQUEST:$ci] Received outbound request $rm $ru from $si:$sp\n");

        # Strip any next-hop TLS or TCP transport attribute before routing 
        # onward, since we want to force to plain UDP for communication to Enswitch.

        $ru = $(ru{s.tolower}{s.rm,;transport=tls}{s.rm,;transport=tcp});

        if(is_method("REGISTER")) {
            $var(tarray) = 0;

            set_contact_alias();
            append_hf("Path: <sip:$Ri:$Rp;lr>\r\n");
            append_hf("Supported: path\r\n");

            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Forwarding registration for AOR $tu upstream\n");

            t_on_reply("REPLY_FROM_PBX");
            $du = "sip:38.101.40.11:8060;transport=udp";

            if(!save("location", "0x02")) {
                sl_reply_error();
                exit;
            }

            if($sht(ib_trans=>$tu:8060) ne $null) {
                $var(tarray) = 0;

                # Atomic removal of RURI from htable, unsuspend initial transaction.

                lock("$tu:8060");
                $var(tarray) = $sht(ib_trans=>$tu:8060);
                $sht(ib_trans=>$tu:8060) = $null;
                unlock("$tu:8060");

                $var(t_index) = $(var(tarray){s.select,0,:}{s.int});
                $var(t_label) = $(var(tarray){s.select,1,:}{s.int});

                mq_add("inbound_q", "$var(t_index):$var(t_label)", "$tu:8060");
            } else if($sht(ib_trans=>stored::$tu:8060) ne $null) {
                # If we don't have anything to resume, but have a stored transaction
                # that was already initiated, just push a new branch onto it. 

                xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Stored transaction present, but nothing suspended; appending branch to existing pending transaction\n");

                ts_append("location", "$tu:8060");
                return;
            }
           
            if(!t_relay())
                sl_reply_error();

            if($var(tarray) != 0)
                ts_store("$tu:8060");                
 
            exit;
        } else if(is_method("INVITE")) {
            add_contact_alias();

            if(has_body("application/sdp")) {
                if(proto == WS || proto == WSS) {
                    rtpengine_manage("replace-origin replace-session-connection ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
                } else {
                    rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU SDES-off RTP/AVP");
                }
            }

            record_route();

            t_on_reply("REPLY_FROM_PBX");

            if(!t_relay())
                sl_reply_error();
        }

        exit;
    } else {
        if(is_method("OPTIONS")) {
            sl_send_reply("200", "OK");
            exit;
        }

        if(is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Received inbound request $rm $ru from $si:$sp\n");

            if(!strempty($(ru{uri.param,pn-prid}))) {
                xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> PN data present\n");
                route(DO_PUSH);
            }

            route(INBOUND_REQUEST_PROCESS_INITIAL);

            exit;
        }

        sl_send_reply("403", "Forbidden");
        exit;
    }

    sl_send_reply("403", "Forbidden");
}

onreply_route[REPLY_FROM_PBX] {
    xlog("L_INFO", "[OR-REPLY-FROM-PBX:$ci] Reply '$rs $rr' from $si:$sp\n");
   
    if(is_method("INVITE")) {
        if(has_body("application/sdp")) {
            if($avp(ws_origin) == 1) {
                rtpengine_manage("replace-origin replace-session-connection trust-address ICE=force UDP/TLS/RTP/SAVP DTLS=passive SDES-off rtcp-mux-offer");
            } else {
                rtpengine_manage("replace-origin replace-session-connection ICE=remove");
            }
        }
    } 
}

onreply_route[REPLY_FROM_ENDPOINT] {
    xlog("L_INFO", "[R-REPLY-FROM-ENDPOINT:$ci] Reply '$rs $rr' from $si:$sp\n");

    if(is_method("INVITE")) {
        add_contact_alias();

        if(has_body("application/sdp")) {
            if(proto == WS || proto == WSS) {
                rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
            } else {
                rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU SDES-off RTP/AVP");
            }
        }
    }
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if($hdr(Upgrade) =~ 'websocket' && $hdr(Connection) =~ 'Upgrade' && is_method("GET")) {
           if(ws_handle_handshake())
                exit;
    }

    xhttp_reply("403", "Forbidden", "", "");
}

# Harvest a push-token out of a RURI and put a push request out of the appropriate type on the mqueue. 

route[DO_PUSH] {
    $var(tok_data) = $(ru{uri.param,pn-prid});
    $var(prov) = $(ru{uri.param,pn-provider});

    if($var(prov) == 0)
        return;

    if($var(prov) eq 'apn' || $var(prov) eq 'apns.dev') {
        $var(j) = 0;
        $var(tok_frag) = 0;
        $var(tok_type) = 0;
        $var(push_tok) = 0;

        while(!strempty($(var(tok_data){s.select,$var(j),&}))) {
            $var(tok_frag) = $(var(tok_data){s.select,$var(j),&});
            $var(tok_type) = $(var(tok_frag){s.select,1,:});

            if($var(tok_type) eq 'voip') {
                $var(push_tok) = $(var(tok_frag){s.select,0,:});
                xlog("L_INFO", "[R-HARVEST-PUSH-TOKEN:$ci] -> Extracted iOS 'voip' token and will attempt APNS push: $var(push_tok)\n");

                $var(obj) = '{}';

                jansson_set("string", "call_id", "$ci", "$var(obj)");
                jansson_set("string", "push_tok", "$var(push_tok)", "$var(obj)");
                jansson_set("string", "sip_from_uri", "$fu", "$var(obj)");
                jansson_set("string", "sip_from_display", "MASOOD", "$var(obj)");
                jansson_set("string", "send_time", "$Ts", "$var(obj)");

                # Also capture pn-provider value, which will influence whether to use 
                # Apple developer sandbox or production push server. Default to 'apns', 
                # which means 'production', whereas 'apns.dev' means 'sandbox'.

                $var(pn_provider) = $(ru{uri.param,pn-provider});

                if(strempty($var(pn_provider)))
                    $var(pn_provider) = 'apns';

                mq_add("push_q", "apns:$(ci{s.encode.base64})", "$var(obj)");
                break;
            }

            $var(j) = $var(j) + 1;
        }
    } else if($var(prov) eq 'fcm') {
        # Compared to APNS ampersand-delimited tokens, Android/FCM is very simple;
        # the pn-prid= value is the token.

        xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Found Android push token -- will attempt FCM push\n");

        $var(obj) = '{}';

        jansson_set("string", "call_id", "$ci", "$var(obj)");
        jansson_set("string", "push_tok", "$var(tok_data)", "$var(obj)");
        jansson_set("string", "sip_from_uri", "$fu", "$var(obj)");
        jansson_set("string", "sip_from_display", "MASOOD", "$var(obj)");
        jansson_set("string", "send_time", "$Ts", "$var(obj)");

        mq_add("push_q", "fcm:$(ci{s.encode.base64})", "$var(obj)");
    }
}

# General inbound request handling, which might need to be called from a variety
# of places -- async callbacks, or straight from the SIP worker process in case
# push notifications aren't indicated.

route[INBOUND_REQUEST_FINALISE] {
    xlog("L_INFO", "[R-INBOUND-REQUEST-FINALISE:$ci] -> Continuing processing of call to $ru\n");

    t_on_branch("INBOUND_REQUEST_BRANCH");

    if(!t_relay())
        sl_reply_error();
}

branch_route[INBOUND_REQUEST_BRANCH] {
    handle_ruri_alias();

    if(is_method("INVITE")) {
        record_route();

        if(has_body("application/sdp")) {
            if($nh(P) eq 'ws' || $nh(P) eq 'wss') {
                rtpengine_manage("replace-origin replace-session-connection trust-address ICE=force UDP/TLS/RTP/SAVP SDES-off DTLS=passive rtcp-mux-offer");
            } else if($nh(P) eq 'tls') {
                # Presume SDES.
                rtpengine_manage("replace-origin replace-session-connection trust-address RTP/SAVP DTLS=off");
            } else {
                rtpengine_manage("replace-origin replace-session-connection trust-address");
            }
        }
    }
   
    t_on_reply("REPLY_FROM_ENDPOINT"); 
}

route[INBOUND_REQUEST_PROCESS_INITIAL] {
    if(!is_present_hf("X-Enswitch-RURI")) {
        xlog("L_ERROR", "[R-INBOUND-REQUEST-PROCESS-INITIAL:$ci] !> No X-Enswitch-RURI header passed from upstream\n");
        send_reply("500", "Internal server error");
        exit;
    }
    
    # If a registration is already active, create this as our transaction instead of
    # suspending the existing one, and just join new branches to it. 

    if(lookup("location", "$hdr(X-Enswitch-RURI)")) {
        xlog("L_INFO", "[R-INBOUND-REQUEST-PROCESS-INITIAL:$ci] -> Resolved contact: $ru\n");
      
	t_on_branch("INBOUND_REQUEST_BRANCH");
	t_on_reply("REPLY_FROM_ENDPOINT");
 
        if(!t_relay()) {
            sl_reply_error();
            exit;
        }

        ts_store("$hdr(X-Enswitch-RURI)");

        # Some indication that we have stored an existing pending transaction value, 
        # so that we can just append branches to it later instead of resuming a
        # suspended transaction.

        $sht(ib_trans=>stored::$hdr(X-Enswitch-URI)) = 1;
 
        return;
    }
      
    # Store to indicate that we have already attempted an invite to this 
    # destination, and do not yet attempt to relay, pending a re-registration or 
    # timeout.

    if(!t_suspend()) {
        sl_send_reply("500", "Server internal error");
        exit;
    }

    $sht(ib_trans=>$hdr(X-Enswitch-RURI)) = $_s($T(id_index):$T(id_label));

    xlog("L_INFO", "[R-INBOUND-REQUEST-PROCESS-INITIAL:$ci] -> Stored $hdr(X-Enswitch-RURI) => $T(id_index):$T(id_label) in stasis\n");
}

# Dequeue the push_q and make synchronous HTTP queries.

route[PUSH_TIMER] {
    while(mq_fetch("push_q")) {
        $var(push_type) = $(mqk(push_q){s.select,0,:});
        $var(call_id) = $(mqk(push_q){s.select,1,:}{s.decode.base64});
        $var(push_obj) = $mqv(push_q);
        $var(push_result) = 0;

        xlog("L_INFO", "[EV-PUSH-TIMER:$var(call_id)] -> Dequeuing push of type: $var(push_type)\n");

        switch($var(push_type)) {
            case "fcm":
                http_connect("push_api", "/push-fcm", "application/json", "$var(push_obj)", "$var(push_result)");
                break;
            case "apns":
                http_connect("push_api", "/push-apns", "application/json", "$var(push_obj)", "$var(push_result)");
                break;
            default:
                xlog("L_ERROR", "[EV-PUSH-TIMER:$var(call_id)] !> Unknown push type!\n");
                mq_pv_free("push_q");
                return;
        }

        xlog("L_INFO", "[EV-PUSH-TIMER:$var(call_id)] -> Push operation result: $var(push_result)\n");

        mq_pv_free("push_q"); 
    }
}

# Dequeue suspended inbound requests and start forking through contacts, 
# laundering any new ones that roll in through the registrar.

route[INBOUND_TIMER] {
    while(mq_fetch("inbound_q")) {
        $var(t_index) = $(mqk(inbound_q){s.select,0,:}{s.int});
        $var(t_label) = $(mqk(inbound_q){s.select,1,:}{s.int});
        $var(ruri) = $mqv(inbound_q);
       
        xlog("L_INFO", "Unloading branches: $var(ruri)\n");
 
        ts_append_to("$var(t_index)", "$var(t_label)", "location", "$var(ruri)");
        t_continue("$var(t_index)", "$var(t_label)", "INBOUND_REQUEST_FINALISE");
    }
}
