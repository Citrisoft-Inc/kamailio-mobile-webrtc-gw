#!KAMAILIO

# A few runtime constants.

#!define PUSH_API_BASE_PATH_FCM "http://172.30.110.2:8084/push-fcm"
#!define PUSH_API_BASE_PATH_APNS "http://172.30.110.2:8084/push-apns"

#!define AUTH_DB_URL "mysql://enswitch:enswh0v3@db06.hovernetworks.net/enswitch"

debug=2
children=8
mhomed=1
enable_tls=1
tcp_accept_no_cl=yes
tcp_max_connections=16384
tls_max_connections=16348
alias=webrtc00.hovernetworks.net
socket_workers=2
listen=udp:38.101.40.92:8060
listen=tls:38.101.40.92:443
socket_workers=4
listen=tcp:38.101.40.92:8060
log_facility=LOG_LOCAL0

loadmodule "pv"
loadmodule "xlog"
loadmodule "ipops"
loadmodule "sdpops"
loadmodule "cfgutils"

loadmodule "tm"
modparam("tm", "blst_503", 0)
modparam("tm", "cancel_b_method", 1)
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 10000)
modparam("tm", "fr_inv_timer", 60000)
modparam("tm", "noisy_ctimer", 1)
modparam("tm", "reparse_invite", 1)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "unmatched_cancel", 1)

loadmodule "rr"
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)
modparam("rr", "enable_full_lr", 1)

loadmodule "rtpengine"
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:5050")
modparam("rtpengine", "rtpengine_retr", 1)

loadmodule "db_mysql"
modparam("db_mysql", "ping_interval", 30)
modparam("db_mysql", "timeout_interval", 1) # really, 3 sec.
modparam("db_mysql", "auto_reconnect", 1)

loadmodule "tls"
modparam("tls", "con_ct_wq_max", 1048576)
modparam("tls", "connection_timeout", 300)
modparam("tls", "ct_wq_max", 26214400)
modparam("tls", "renegotiation", 1)
modparam("tls", "require_certificate", 0)
modparam("tls", "send_close_notify", 1)
modparam("tls", "tls_disable_compression", 1)
modparam("tls", "tls_method", "TLSv1.1+")
modparam("tls", "verify_certificate", 0)
modparam("tls", "private_key", TLS_SERVER_KEY)
modparam("tls", "certificate", TLS_SERVER_CERT)

loadmodule "sanity"
modparam("sanity", "default_checks", 359)

loadmodule "kex"
loadmodule "maxfwd"
loadmodule "nathelper"
loadmodule "jansson"
loadmodule "siputils"
loadmodule "sl"
loadmodule "textops"
loadmodule "textopsx"
loadmodule "tmx"
loadmodule "xhttp"

loadmodule "websocket"
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 3)
modparam("websocket", "keepalive_interval", 5)
modparam("websocket", "cors_mode", 1)

loadmodule "ctl"
modparam("ctl", "binrpc", "unixs:/tmp/kamailio_ctl")
modparam("ctl", "binrpc_buffer_size", 1048576)
modparam("ctl", "mode", 0600)
modparam("ctl", "binrpc_max_body_size", 1024)
modparam("ctl", "binrpc_struct_max_body_size", 1024)

loadmodule "http_async_client"
modparam("http_async_client", "workers", 4)
modparam("http_async_client", "connection_timeout", 1000)
modparam("http_async_client", "tls_verify_host", 0)
modparam("http_async_client", "tls_verify_peer", 0)

loadmodule "usrloc"
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "desc_time_order", 1)
modparam("usrloc", "hash_size", 16)
modparam("usrloc", "matching_mode", 0)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 4)
modparam("usrloc", "use_domain", 1)

loadmodule "registrar"
modparam("registrar", "default_expires", 600)
modparam("registrar", "min_expires", 30)
modparam("registrar", "max_expires", 1800)
modparam("registrar", "append_branches", 1)
modparam("registrar", "max_contacts", 2)
modparam("registrar", "gruu_enabled", 1)
modparam("registrar", "contact_max_size", 1024)

loadmodule "tsilo"
modparam("tsilo", "hash_size", 2048)
modparam("tsilo", "use_domain", 1)

loadmodule "htable"
modparam("htable", "htable", "reg_cseq=>size=16;autoexpire=604800")

loadmodule "auth"
modparam("auth", "qop", "auth")
modparam("auth", "nonce_count", 1)

loadmodule "auth_db"
modparam("auth_db", "db_url", AUTH_DB_URL)
modparam("auth_db", "user_column", "name")
modparam("auth_db", "password_column", "secret")
modparam("auth_db", "use_domain", 0)
modparam("auth_db", "calculate_ha1", 1)

request_route {
    $avp(ws_origin) = 0;

    # Some basic sanity checks.

    if(!mf_process_maxfwd_header("10") && !is_method("REGISTER|OPTIONS")) {
        send_reply("483", "Too Many Hops");
        exit;
    }

    if(!sanity_check())
        exit;

    if(proto == WS || proto == WSS) {
        force_rport();
        $avp(ws_origin) = 1;
    }

    # In-dialog request handling.
    if(has_totag()) {
        if(loose_route()) {
            xlog("L_INFO", "[R-MAIN:$ci] Processing in-dialog request $rm $ru from $si:$sp\n");

            handle_ruri_alias();

            if(is_method("INVITE|UPDATE")) {
                if(has_body("application/sdp")) {
                    if(proto == WS || proto == WSS) {
                        rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
                    } else {
                        rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU");
                    }
                }

                # Keep up with any target refreshes.
                if(!is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
                    add_contact_alias();
                    t_on_reply("REPLY_FROM_PBX");
                } else {
                    t_on_reply("REPLY_FROM_ENDPOINT");
                }
            } 

            if(!t_relay()) 
                sl_reply_error();
        } else {
            if(is_method("ACK")) {
                if(t_check_trans())
                    t_relay();

                exit;
            }

            send_reply("403", "Forbidden");
        }

        exit;
    }

    if(is_method("CANCEL")) {
        if(!t_relay_cancel())
            send_reply("500", "Internal Server Error");

        exit;
    }

    # Retransmission dampening, then handle initial requests.
    t_check_trans();

    # If there is a foreign domain, make sure it matches the upstream 
    # trusted PBX, otherwise reject.

    if(!uri == myself && !is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
        if(!is_in_subnet("$rd", PBX_SERVER_ADDRESSES)) {
            send_reply("403", "Relay not permitted");
            exit;
        }

        xlog("L_INFO", "[R-MAIN-REQUEST:$ci] Received outbound request $rm $ru from $si:$sp\n");

        # Strip any next-hop TLS or TCP transport attribute before routing 
        # onward, since we want to force to plain UDP for communication to Enswitch.

        $ru = $(ru{s.tolower}{s.rm,;transport=tls}{s.rm,;transport=tcp});

        if(is_method("REGISTER")) {
            if(!auth_check("$td", "phones", "1")) {
                xlog("L_INFO", "[R-MAIN-REQUEST:$ci] Registration not authorised; issuing authentication challenge\n");
                auth_challenge("$td", 1);
                exit;
            }

            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> User '$au' authenticated successfully\n");

            consume_credentials();

            set_contact_alias();

            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Shadow-storing contact for: $tu:8060\n");
            save("location", "0", "$tu:8060");
          
            # Because ts_append() appends new branches, we can't have upstream relay efforts
            # confusing the situation here. So, we synthesise our own, independent upstream
            # registration renewal request. This also alleviates the tension between the
            # need for short/ephemeral registrations on mobile clients, vs. the need for a 
            # persistent registration upstream to allow call delivery to happen in the first
            # place.

            # We also keep state for CSeq so that it can be increased for same Call-ID.

            if($sht(reg_cseq=>$tu) eq $null) { 
                $var(cseq) = $RANDOM / 131072;
                $sht(reg_cseq=>$tu) = $var(cseq);
            } else 
                $var(cseq) = $shtinc(reg_cseq=>$tu);

            t_uac_send("REGISTER", 
                       "sip:38.101.40.11:8060;transport=udp",
                       "", 
                       "",
                            "To: $tu\r\n" + 
                            "From: $tu\r\n" + 
                            "Call-ID: $(tu{s.md5})\n" + 
                            "CSeq: $var(cseq) REGISTER\r\n" +
                            "Expires: 86400\r\n" + 
                            "Contact: sip:$tU@$Ri:$Rp\r\n",
                       "");
 
            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Attempting to retrieve siloed transactions for RURI $tu:8060\n");
 
            if(ts_append("location", "$tu:8060")) {
                xlog("L_ERR", "[R-MAIN-REQUEST:$ci] -> Successfully retrieved siloed transactions for $tu:8060\n");
                exit;
            }

            exit;
        } else if(is_method("INVITE")) {
            add_contact_alias();

            if(has_body("application/sdp")) {
                if(proto == WS || proto == WSS) {
                    rtpengine_manage("replace-origin replace-session-connection ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
                } else {
                    rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU SDES-off RTP/AVP");
                }
            }

            record_route();

            t_on_reply("REPLY_FROM_PBX");

            if(!t_relay())
                sl_reply_error();
        }

        exit;
    } else {
        if(is_method("OPTIONS")) {
            sl_send_reply("200", "OK");
            exit;
        }

        if(is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] Received inbound request $rm $ru from $si:$sp\n");

            $var(tok_data) = 0;

            #$var(tok_data) = $(ru{uri.param,pn-prid});

            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Trying to fetch contact details for $hdr(X-Enswitch-RURI)\n");

            # Interrogate our shadow location DB for the user agent in order to know 
            # which push notification service to use and how to behave.

            if(reg_fetch_contacts("location", "$hdr(X-Enswitch-RURI)", "ua")) {
                $var(i) = 0;
                $var(tok_data) = 0;
                $var(user_agent) = '';
                $var(pn_provider) = '';

                while($var(i) < $ulc(ua=>count)) {
                   $var(user_agent) = $(ulc(ua=>user_agent)[$var(i)]);

                    xlog("L_INFO", "[R-MAIN-REQUEST:$ci] Contact cycle [$var(i)]: $var(user_agent)\n");

                    # If no pn-prid push-token stored for this contact, then attempt to contact them
                    # in the "ordinary fashion".

                    $var(tok_data) = $(ulc(ua=>addr){uri.param,pn-prid});

                    if(strempty($var(tok_data))) {
                        xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> No push token found, so proceeding with regular routing\n");
                        route(INBOUND_REQUEST_FINALISE);
                    } else {
                        if($var(user_agent) =~ 'iOS') {
                            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Push notification treatment: APNS\n");

                            # Parse out the :voip token -- split pn-prid value by '&' 
                            # delimiter and then attempt to find what we want. 

                            $var(j) = 0;
                            $var(tok_frag) = 0;
                            $var(tok_type) = 0;
                            $var(push_tok) = 0;

                            while(!strempty($(var(tok_data){s.select,$var(j),&}))) {
                                $var(tok_frag) = $(var(tok_data){s.select,$var(j),&});
                                $var(tok_type) = $(var(tok_frag){s.select,1,:});

                                if($var(tok_type) eq 'voip') {
                                    $var(push_tok) = $(var(tok_frag){s.select,0,:});
                                    xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Extracted 'voip' token: $var(push_tok)\n");
                                    break;
                                }

                                $var(j) = $var(j) + 1;
                            }

                            if($var(push_tok) ne '0') {
                                $var(obj) = '{}';

                                jansson_set("string", "call_id", "$ci", "$var(obj)");
                                jansson_set("string", "push_tok", "$var(push_tok)", "$var(obj)");
                                jansson_set("string", "sip_from_uri", "$fu", "$var(obj)");
                                jansson_set("string", "sip_from_display", "MASOOD", "$var(obj)");
                                jansson_set("string", "send_time", "$Ts", "$var(obj)");

                                # Also capture pn-provider value, which will influence whether to use 
                                # Apple developer sandbox or production push server. Default to 'apns', 
                                # which means 'production', whereas 'apns.dev' means 'sandbox'.

                                $var(pn_provider) = $(ru{uri.param,pn-provider});

                                if(strempty($var(pn_provider)))
                                    $var(pn_provider) = 'apns';

                                sl_send_reply("100", "Trying");
                                t_set_auto_inv_100(0);

                                if(t_newtran()) 
                                    ts_store();

                                $http_req(all) = $null;

                                $http_req(timeout) = 1000;
                                $http_req(suspend) = 1;
                                $http_req(body) = $var(obj);
                                $http_req(method) = 'POST';

                                http_async_query(PUSH_API_BASE_PATH_APNS + "?provider=$var(pn_provider)", "HTTP_PUSH_REPLY");
                            }
                        } else if($var(user_agent) =~ 'Unknown') {
                            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] -> Push notification treatment: FCM\n");

                            $var(obj) = '{}';

                            jansson_set("string", "call_id", "$ci", "$var(obj)");
                            jansson_set("string", "push_tok", "$var(tok_data)", "$var(obj)");
                            jansson_set("string", "sip_from_uri", "$fu", "$var(obj)");
                            jansson_set("string", "sip_from_display", "MASOOD", "$var(obj)");
                            jansson_set("string", "send_time", "$Ts", "$var(obj)");

                            sl_send_reply("100", "Trying");
                            t_set_auto_inv_100(0);

                            if(t_newtran()) 
                                ts_store();

                            $http_req(all) = $null;

                            $http_req(timeout) = 1000;
                            $http_req(suspend) = 1;
                            $http_req(body) = $var(obj);
                            $http_req(method) = 'POST';

                            http_async_query(PUSH_API_BASE_PATH_FCM, "HTTP_PUSH_REPLY");
                        }
                    }

                    $var(i) = $var(i) + 1;
                }
            } else {
                xlog("L_INFO", "[R-MAIN-REQUEST:$ci] !> No contacts found for this AOR -- rejecting\n");
                sl_send_reply("404", "Not Found");
                exit;
            }

            exit;
        }

        sl_send_reply("403", "Forbidden");
        exit;
    }

    sl_send_reply("403", "Forbidden");
}

onreply_route[REPLY_FROM_PBX] {
    xlog("L_INFO", "[OR-REPLY-FROM-PBX:$ci] Reply '$rs $rr' from $si:$sp\n");
   
    if(is_method("INVITE")) {
        if(has_body("application/sdp")) {
            if($avp(ws_origin) == 1) {
                rtpengine_manage("replace-origin replace-session-connection trust-address ICE=force UDP/TLS/RTP/SAVP DTLS=passive SDES-off rtcp-mux-offer");
            } else {
                rtpengine_manage("replace-origin replace-session-connection ICE=remove");
            }
        }
    } 
}

onreply_route[REPLY_FROM_ENDPOINT] {
    xlog("L_INFO", "[R-REPLY-FROM-ENDPOINT:$ci] Reply '$rs $rr' from $si:$sp\n");

    if(is_method("INVITE")) {
        add_contact_alias();

        if(has_body("application/sdp")) {
            if(proto == WS || proto == WSS) {
                rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
            } else {
                rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU SDES-off RTP/AVP");
            }
        }
    }
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if($hdr(Upgrade) =~ 'websocket' && $hdr(Connection) =~ 'Upgrade' && is_method("GET")) {
           if(ws_handle_handshake())
                exit;
    }

    xhttp_reply("403", "Forbidden", "", "");
}

# General inbound request handling, which might need to be called from a variety
# of places -- async callbacks, or straight from the SIP worker process in case
# push notifications aren't indicated.

route[INBOUND_REQUEST_FINALISE] {
    # Use our shadow registrar to resolve the AOR contacts on our side.

    if(!is_present_hf("X-Enswitch-RURI")) {
        xlog("L_ERROR", "[R-INBOUND-REQUEST-FINALISE:$ci] !> No X-Enswitch-RURI header passed from upstream\n");
        sl_send_reply("500", "Internal server error");
        exit;
    }

    if(!lookup("location", "$hdr(X-Enswitch-RURI)")) {
        xlog("L_INFO", "[R-INBOUND-REQUEST-FINALISE:$ci] !> Unable to resolve: $hdr(X-Enswitch-RURI)\n");
        sl_send_reply("404", "Not Found");
        exit;
    }

    xlog("L_INFO", "[R-INBOUND-REQUEST-FINALISE:$ci] -> Resolved: $ru\n");

    if(is_method("INVITE")) {
        record_route();

        if(has_body("application/sdp")) {
            if($nh(P) eq 'ws' || $nh(P) eq 'wss') {
                rtpengine_manage("replace-origin replace-session-connection trust-address ICE=force UDP/TLS/RTP/SAVP SDES-off DTLS=passive rtcp-mux-offer");
            } else if($nh(P) eq 'tls') {
                # Presume SDES.
                rtpengine_manage("replace-origin replace-session-connection trust-address RTP/SAVP DTLS=off");
            } else {
                rtpengine_manage("replace-origin replace-session-connection trust-address");
            }
        }
    }

    # Remove leaky Enswitch headers.
    remove_hf("X-Enswitch-RURI");
    remove_hf("X-Enswitch-Source");
    remove_hf("X-Enswitch-External");

    handle_ruri_alias();

    t_on_reply("REPLY_FROM_ENDPOINT");

    if(!t_relay() )
        sl_reply_error();
}

# Specialty HTTP reply routes.

route[HTTP_PUSH_REPLY] {
    xlog("L_INFO", "[EV-HTTP-PUSH-REPLY:$ci] -> HTTP reply: $http_ok\n");
    route(INBOUND_REQUEST_FINALISE);
}
