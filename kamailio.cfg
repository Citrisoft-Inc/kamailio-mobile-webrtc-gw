#!KAMAILIO

debug=2
children=8
mhomed=1
enable_tls=1
tcp_accept_no_cl=yes
tcp_max_connections=16384
tls_max_connections=16348
alias=webrtc00.hovernetworks.net
listen=udp:38.101.40.92:5060
listen=tls:38.101.40.92:443
listen=tcp:38.101.40.92:5060

loadmodule "pv"
loadmodule "xlog"
loadmodule "ipops"
loadmodule "sdpops"

loadmodule "tm"
modparam("tm", "blst_503", 0)
modparam("tm", "cancel_b_method", 1)
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 2000)
modparam("tm", "fr_inv_timer", 60000)
modparam("tm", "noisy_ctimer", 1)
modparam("tm", "reparse_invite", 1)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "unmatched_cancel", 1)

loadmodule "rr"
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)
modparam("rr", "enable_full_lr", 1)

loadmodule "rtpengine"
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:5050")
modparam("rtpengine", "rtpengine_retr", 1)

loadmodule "tls"
modparam("tls", "con_ct_wq_max", 1048576)
modparam("tls", "connection_timeout", 300)
modparam("tls", "ct_wq_max", 26214400)
modparam("tls", "renegotiation", 1)
modparam("tls", "require_certificate", 0)
modparam("tls", "send_close_notify", 1)
modparam("tls", "tls_disable_compression", 1)
modparam("tls", "tls_method", "TLSv1.1+")
modparam("tls", "verify_certificate", 0)
modparam("tls", "private_key", TLS_SERVER_KEY)
modparam("tls", "certificate", TLS_SERVER_CERT)

loadmodule "kex"
loadmodule "maxfwd"
loadmodule "nathelper"
loadmodule "sanity"
modparam("sanity", "default_checks", 487)

loadmodule "siputils"
loadmodule "sl"
loadmodule "textops"
loadmodule "textopsx"
loadmodule "tmx"
loadmodule "xhttp"
loadmodule "path"

loadmodule "websocket"
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 3)
modparam("websocket", "keepalive_interval", 5)
modparam("websocket", "cors_mode", 1)

loadmodule "ctl"
modparam("ctl", "binrpc", "unixs:/tmp/kamailio_ctl")
modparam("ctl", "binrpc_buffer_size", 1048576)
modparam("ctl", "mode", 0600)
modparam("ctl", "binrpc_max_body_size", 1024)
modparam("ctl", "binrpc_struct_max_body_size", 1024)

request_route {
    $avp(ws_origin) = 0;

    # Some basic sanity checks.

    if(!mf_process_maxfwd_header("10") && !is_method("REGISTER|OPTIONS")) {
        send_reply("483", "Too Many Hops");
        exit;
    }

    if(!sanity_check())
        exit;

    if(proto == WS || proto == WSS) {
        force_rport();
        $avp(ws_origin) = 1;
    }

    # In-dialog request handling.
    if(has_totag()) {
        if(loose_route()) {
            xlog("L_INFO", "[R-MAIN:$ci] Processing in-dialog request $rm $ru from $si:$sp\n");

            handle_ruri_alias();

            if(is_method("INVITE|UPDATE")) {
                if(has_body("application/sdp")) {
                    if(proto == WS || proto == WSS) {
                        rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
                    } else {
                        rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU");
                    }
                }

                # Keep up with any target refreshes.
                if(!is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
                    add_contact_alias();
                    t_on_reply("REPLY_FROM_PBX");
                } else {
                    t_on_reply("REPLY_FROM_ENDPOINT");
                }
            } 

            if(!t_relay()) 
                sl_reply_error();
        } else {
            if(is_method("ACK")) {
                if(t_check_trans())
                    t_relay();

                exit;
            }

            send_reply("403", "Forbidden");
        }

        exit;
    }

    if(is_method("CANCEL")) {
        if(!t_relay_cancel())
            send_reply("500", "Internal Server Error");

        exit;
    }

    # Retransmission dampening, then handle initial requests.
    t_check_trans();

    # If there is a foreign domain, make sure it matches the upstream 
    # trusted PBX, otherwise reject.

    if(!uri == myself && !is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
        if(!is_in_subnet("$rd", PBX_SERVER_ADDRESSES)) {
            send_reply("403", "Relay not permitted");
            exit;
        }

        xlog("L_INFO", "[R-MAIN-REQUEST:$ci] Received outbound request $rm $ru from $si:$sp\n");

        # Strip any next-hop TLS transport attribute before routing onward, since 
        # we want to force to plain UDP for communication to Enswitch.

        $ru = $(ru{s.rm,;transport=TLS});
        $ru = $(ru{s.rm,;transport=tls});

        if(is_method("REGISTER")) {
            add_contact_alias();
            add_path(); 
	    
            if(!is_present_hf("Supported"))
                append_hf("Supported: path\r\n");
        } else if(is_method("INVITE")) {
            add_contact_alias();

            if(has_body("application/sdp")) {
                if(proto == WS || proto == WSS) {
                    rtpengine_manage("replace-origin replace-session-connection ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
                } else {
                    rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU SDES-off RTP/AVP");
                }
            }

            record_route();
        } 

        t_on_reply("REPLY_FROM_PBX");

        if(!t_relay())
            sl_reply_error();

        exit;
    } else {
        if(is_method("OPTIONS")) {
            sl_send_reply("200", "OK");
            exit;
        }

        if(is_in_subnet("$si", PBX_SERVER_ADDRESSES)) {
            xlog("L_INFO", "[R-MAIN-REQUEST:$ci] Received inbound request $rm $ru from $si:$sp\n");

            if(is_method("INVITE")) {
                record_route();

                if(has_body("application/sdp")) {
                    if($nh(P) eq 'ws' || $nh(P) eq 'wss') {
                        rtpengine_manage("replace-origin replace-session-connection trust-address ICE=force UDP/TLS/RTP/SAVP SDES-off DTLS=passive rtcp-mux-offer");
                    } else {
                        rtpengine_manage("replace-origin replace-session-connection trust-address");
                    }
                }
            }

            handle_ruri_alias();
            t_on_reply("REPLY_FROM_ENDPOINT");

            if(!t_relay()) 
                sl_reply_error();

            exit;
        }

        sl_send_reply("403", "Forbidden");
        exit;
    }

    sl_send_reply("403", "Forbidden");
}

onreply_route[REPLY_FROM_PBX] {
    xlog("L_INFO", "[OR-REPLY-FROM-PBX:$ci] Reply '$rs $rr' from $si:$sp\n");
   
    if(is_method("INVITE")) {
        if(has_body("application/sdp")) {
            if($avp(ws_origin) == 1) {
                rtpengine_manage("replace-origin replace-session-connection trust-address ICE=force UDP/TLS/RTP/SAVP DTLS=passive SDES-off rtcp-mux-offer");
            } else {
                rtpengine_manage("replace-origin replace-session-connection ICE=remove");
            }
        }
    } 
}

onreply_route[REPLY_FROM_ENDPOINT] {
    xlog("L_INFO", "[R-REPLY-FROM-ENDPOINT:$ci] Reply '$rs $rr' from $si:$sp\n");

    if(is_method("INVITE")) {
        add_contact_alias();

        if(has_body("application/sdp")) {
            if(proto == WS || proto == WSS) {
                rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU ICE=remove rtcp-mux-demux SDES-off RTP/AVP");
            } else {
                rtpengine_manage("replace-origin replace-session-connection codec-strip=all codec-offer=PCMU");
            }
        }
    }
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if($hdr(Upgrade) =~ 'websocket' && $hdr(Connection) =~ 'Upgrade' && is_method("GET")) {
           if(ws_handle_handshake())
                exit;
    }

    xhttp_reply("403", "Forbidden", "", "");
}
